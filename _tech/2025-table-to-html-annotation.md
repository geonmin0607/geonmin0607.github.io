---
title: "표 → HTML 구조 데이터셋 설계 — 3단계 표현, 오류 태깅, 평가 지표"
subtitle: "Table 구조를 LLM/VLM이 이해할 수 있는 형태로 바꾸는 방법"
---

이 글은 문서 이미지 속 표를 **정확한 `<table>` HTML 구조로 복원**하기 위해
내가 설계한 데이터셋·어노테이션 방식을 정리한 것이다.

## 1. 왜 Table → HTML 구조가 어려운가?

단순 OCR은 셀 안의 텍스트만 잘 읽으면 되지만,  
실제 서비스에서 중요한 것은 다음과 같다.

- 어떤 셀이 **헤더**인지, 어떤 셀이 **데이터**인지
- 셀 병합(`rowspan`, `colspan`)이 어떻게 되어 있는지
- 사람이 보는 것과 거의 동일한 구조로 재구성되는지

LLM/VLM에게 “그냥 표를 만들어줘”라고 하면  
언어 prior대로 임의의 표를 hallucination 할 수 있다.  
그래서 **정답 구조를 잘 정의한 데이터셋**이 핵심이 된다.

## 2. 3단계 표현 방식 — Base / Escaped / Final

하나의 표를 다음 세 가지 관점으로 나눠서 표현했다.

1. **Base 구조 (raw table 구조)**
   - 셀 단위 텍스트와 좌표를 기반으로 한 **논리적 구조**
   - 병합 전 구조(중복 셀 포함)의 형태로 표현
   - 예: 3x4 그리드, 각 칸에 텍스트/타입(header/data) 정보

2. **Escaped HTML (시각 표현용, 중간 단계)**
   - `<table>`, `<tr>`, `<td>` 구조를 만들되,
   - 태그/따옴표를 escape 해 JSON 안에서 안전하게 다룰 수 있게 한 버전
   - 여기에 `rowspan`, `colspan`, `<span>` 태그 등을 포함시켜
     **시각 표현까지 가능한 구조**를 담는다.

3. **Final HTML (렌더링 가능한 결과)**
   - 실제 브라우저/뷰어에서 바로 렌더링 가능한 `<table>...</table>`
   - 스타일 태그는 최소화하고, 구조 보존에 집중

데이터셋은 보통 다음과 같은 필드를 가진다.

- `base_structure` (또는 유사 키) — 논리적 표 구조
- `escaped_response` — escape 처리된 HTML 문자열
- `response` 또는 `html` — 최종 렌더링 가능한 HTML

이 3단계 구조를 통해,

- 모델은 `base_structure` → `escaped_response` → `response`의
  **단계별 변환**을 학습할 수 있고,
- 평가 시에도 어떤 단계에서 오류가 났는지 추적하기 쉽다.

## 3. 오류 태깅 — Negative Case를 데이터로 삼기

현실 데이터에는 항상 **깨진 HTML / 잘못된 구조**가 섞인다.

나는 이 부분을 단순히 “버리는 데이터”로 취급하지 않고,  
오히려 **오류 유형을 태깅해 학습·평가에 활용**했다.

대표적인 오류 유형 예:

- 태그 미닫힘 오류: `<td>`는 있는데 `</td>`가 없음
- 잘못된 중첩: `<tr>` 안에 `<table>`이 들어가는 등 구조 위반
- rowspan/colspan 불일치: 열/행 수가 맞지 않음
- escape 누락: JSON 문자열 안에서 `"`가 이스케이프되지 않은 경우 등

각 샘플에 대해:

- `error_types`: `["missing_closing_tag", "invalid_rowspan"]` 같은 리스트
- `has_error`: Boolean 플래그

를 두고,

- “오류를 **설명하고 고치는 태스크**”
- “정상/오류 여부를 판별하는 태스크”

까지 포함해서 모델을 학습시킬 수 있도록 설계했다.

## 4. Annotation Flow — Data 관점에서의 파이프라인

표 데이터셋 구축은 다음과 같은 흐름으로 진행했다.

1. **원본 문서/이미지 수집**
   - 스캔 문서, 보고서, 논문, 공공 데이터 등 다양한 도메인
2. **레이아웃 분석 & 셀 추출**
   - PaddleOCR / DocLayout 등의 결과를 바탕으로 표 영역과 셀 박스 추출
3. **셀 기준 텍스트 정렬**
   - OCR 결과를 셀 좌표 기준으로 매핑
   - header / body / summary 등 role 태깅(가능할 경우)
4. **Base 구조 생성**
   - 셀 그리드, 병합 전 구조를 JSON 형태로 표현
5. **HTML 생성 & 검증**
   - Base 구조를 기반으로 `<table>` HTML 생성
   - 자동 검사 + 일부 수동 검수를 통해 오류 유형 태깅
6. **멀티모달 태스크 연결**
   - 표 이미지 + HTML 쌍으로 Qwen-VL 계열을 학습
   - 필요 시 “오류 설명 및 수정” 태스크까지 포함

이 과정은 단순 어노테이션을 넘어서  
**“모델이 실제로 잘 쓸 수 있는 데이터 구조”를 만드는 작업**에 가깝다.

## 5. 평가 지표 — 토큰 정확도만으로는 부족하다

Table → HTML 태스크를 평가할 때는 단순 정확도 외에 여러 지표를 함께 봤다.

- **문자/토큰 수준 지표**
  - Levenshtein 거리
  - 토큰 단위 precision / recall / F1
- **구조 수준 지표**
  - `<tr>`, `<td>`, `<th>` 등 태그 개수 일치 여부
  - rowspan/colspan 조합이 정답과 같은지
  - 렌더링 후 셀 개수/레이아웃 비교 (가능한 경우)
- **LLM-as-a-Judge**
  - “사람이 봤을 때 같은 표로 보이는가?”를 평가하는 LLM 기반 지표

특히 **구조 오류가 난 샘플**을 별도로 모아

- 어떤 패턴에서 모델이 자주 실수하는지
- 데이터·프롬프트·모델 중 어디를 손봐야 하는지

를 분석하는 데 활용했다.

## 6. 정리 — 나의 Table 데이터 설계 강점

- 표를 **단순 텍스트가 아닌 “구조 있는 데이터”**로 정의
- Base/escaped/final 3단계 표현으로 **학습·평가·디버깅을 명확히 분리**
- HTML 오류까지 태깅해 **Negative Case도 학습/분석 자원으로 활용**
- Qwen-VL, OCR, 레이아웃 분석 결과와 연계해
  **실제 문서 파이프라인에서 바로 쓸 수 있는 형태**로 설계

결국 핵심은,  
“모델이 답을 잘 만드는 것” 이전에  
**“모델이 일하기 좋은 데이터와 표현을 설계하는 것”**이라고 생각한다.
